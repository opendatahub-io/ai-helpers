#!/bin/bash
# Compare CVEs between two OCI container images
# Usage: ./check_cves.sh <base_image> <target_image> [output_directory]
# Generates reports showing fixed CVEs, new CVEs, and common CVEs

set -euo pipefail

# Private registry authentication (optional)
# Trivy supports multiple authentication methods:
# 1. REGISTRY_AUTH_FILE: Path to auth.json (e.g., /home/default/containers/auth.json)
# 2. Podman auth config: ${XDG_RUNTIME_DIR}/containers/auth.json (automatically detected)
# 3. Environment variables: TRIVY_USERNAME, TRIVY_PASSWORD
# 4. Non-SSL registries: TRIVY_NON_SSL=true
# 5. Custom timeout: TRIVY_TIMEOUT (default: 5m)
# Set these before running the script if needed

# Parse arguments
if [ $# -lt 2 ]; then
    echo "Usage: $0 <base_image> <target_image> [output_directory]" >&2
    echo "" >&2
    echo "Examples:" >&2
    echo "  $0 registry.io/app:v1.0 registry.io/app:v1.1" >&2
    echo "  $0 docker.io/library/python:3.11 docker.io/library/python:3.12 ./reports" >&2
    exit 1
fi

BASE_IMAGE="$1"
TARGET_IMAGE="$2"
OUTPUT_DIR="${3:-./cve-reports}"

# Create output directory
mkdir -p "$OUTPUT_DIR"

# Create persistent cache directory in output directory for resumability
OCI_CACHE_DIR="${OUTPUT_DIR}/.oci-cache"
mkdir -p "$OCI_CACHE_DIR"

# Note: We keep the cache persistent for resumability
# Users can manually delete ${OUTPUT_DIR}/.oci-cache/ after successful runs

# Unified function to process an image: inspect -> copy -> scan
# Parameters:
#   $1: image reference (e.g., registry.io/image:tag)
#   $2: cache identifier (e.g., "base" or "target")
# Returns: scan file path via stdout
process_image() {
    local image_ref="$1"
    local cache_id="$2"

    # Step 1: Inspect image and get metadata
    local inspect_output
    inspect_output=$(skopeo inspect "docker://${image_ref}" ${REGISTRY_AUTH_FILE:+--authfile "$REGISTRY_AUTH_FILE"} 2>&1) || {
        echo "Error: Image '${image_ref}' not found or not accessible" >&2
        return 1
    }

    local digest
    digest=$(echo "$inspect_output" | jq -r '.Digest' | cut -d':' -f2 | cut -c1-12)
    local image_name
    image_name=$(echo "$image_ref" | sed 's|.*/||' | sed 's/:/-/')
    local tag
    tag=$(echo "$image_ref" | sed 's/.*://' | sed 's/[^a-zA-Z0-9._-]/_/g')

    local oci_path="${OCI_CACHE_DIR}/${cache_id}"
    local scan_file="${OUTPUT_DIR}/${image_name}_${digest}.json"

    # Step 2: Copy image to OCI format (skip if already cached)
    if [ -d "${oci_path}" ]; then
        echo "[${cache_id}] Using cached image" >&2
    else
        echo "[${cache_id}] Copying ${image_ref}..." >&2

        # Try with --preserve-digests first (better for reproducibility)
        # Temporarily disable errexit to check PIPESTATUS after pipeline
        set +e
        skopeo copy ${REGISTRY_AUTH_FILE:+--authfile "$REGISTRY_AUTH_FILE"} \
            --insecure-policy --remove-signatures \
            --preserve-digests --all \
            "docker://${image_ref}" \
            "oci:${oci_path}:${tag}" 2>&1 | sed "s/^/[${cache_id}] /" >&2
        local skopeo_exit="${PIPESTATUS[0]}"
        set -e

        # Check skopeo's exit code (PIPESTATUS[0]), not sed's
        if [ "$skopeo_exit" -ne 0 ]; then
            # If it fails (likely due to manifest list conversion), retry without --preserve-digests
            echo "[${cache_id}] Retrying without --preserve-digests (manifest list conversion required)..." >&2

            # Temporarily disable errexit for retry pipeline
            set +e
            skopeo copy ${REGISTRY_AUTH_FILE:+--authfile "$REGISTRY_AUTH_FILE"} \
                --insecure-policy --remove-signatures \
                --all \
                "docker://${image_ref}" \
                "oci:${oci_path}:${tag}" 2>&1 | sed "s/^/[${cache_id}] /" >&2
            skopeo_exit="${PIPESTATUS[0]}"
            set -e

            # Check skopeo's exit code again
            if [ "$skopeo_exit" -ne 0 ]; then
                echo "[${cache_id}] Error: Failed to copy image to OCI format" >&2
                return 1
            fi
        fi
    fi

    # Step 3: Scan image with trivy (skip if scan file already exists)
    if [ -f "${scan_file}" ]; then
        echo "[${cache_id}] Scan file already exists: ${scan_file}" >&2
    else
        echo "[${cache_id}] Scanning image..." >&2
        trivy image --input "${oci_path}" --no-progress --format json -o "${scan_file}" || {
            echo "[${cache_id}] Error: Failed to scan image" >&2
            return 1
        }
        echo "[${cache_id}] Scan saved to: ${scan_file}" >&2
    fi

    # Return scan file path
    echo "${scan_file}"
}

# Process both images in parallel
echo "[1/3] Processing images in parallel..."

# Track background PIDs for cleanup
BASE_PID=""
TARGET_PID=""

# Cleanup function to kill background processes
cleanup_processes() {
    local exit_code=$?
    if [ -n "$BASE_PID" ]; then
        kill "$BASE_PID" 2>/dev/null || true
    fi
    if [ -n "$TARGET_PID" ]; then
        kill "$TARGET_PID" 2>/dev/null || true
    fi
    # Wait to ensure processes are fully terminated
    wait 2>/dev/null || true
    return $exit_code
}

# Set trap to cleanup background processes on exit
trap cleanup_processes EXIT INT TERM

# Process base image in background
(
    BASE_SCAN_FILE=$(process_image "$BASE_IMAGE" "base") || exit 1
    echo "${BASE_SCAN_FILE}" > "$OUTPUT_DIR/.base_scan_file.tmp"
) &
BASE_PID=$!

# Process target image in background
(
    TARGET_SCAN_FILE=$(process_image "$TARGET_IMAGE" "target") || exit 1
    echo "${TARGET_SCAN_FILE}" > "$OUTPUT_DIR/.target_scan_file.tmp"
) &
TARGET_PID=$!

# Wait for both processes and collect exit codes
BASE_EXIT=0
TARGET_EXIT=0

wait $BASE_PID || BASE_EXIT=$?
wait $TARGET_PID || TARGET_EXIT=$?

# Check if either process failed
if [ $BASE_EXIT -ne 0 ]; then
    echo "Error: Base image processing failed" >&2
    exit 1
fi

if [ $TARGET_EXIT -ne 0 ]; then
    echo "Error: Target image processing failed" >&2
    exit 1
fi

# Clear the trap and unset PIDs to prevent cleanup_processes from acting on stale PIDs
trap - EXIT INT TERM
BASE_PID=""
TARGET_PID=""

# Read scan file paths from temp files
BASE_SCAN_FILE=$(cat "$OUTPUT_DIR/.base_scan_file.tmp")
TARGET_SCAN_FILE=$(cat "$OUTPUT_DIR/.target_scan_file.tmp")

echo "Both images processed successfully"

# Extract CVE lists
echo "[2/3] Extracting CVE data..."

# Extract CVEs from base image
jq -r '.Results[]?.Vulnerabilities[]? | "\(.VulnerabilityID)|\(.Severity)|\(.PkgName)|\(.InstalledVersion)|\(.Title // "N/A")"' \
    "${BASE_SCAN_FILE}" | sort -u > "$OUTPUT_DIR/base_cves.tmp"

# Extract CVEs from target image
jq -r '.Results[]?.Vulnerabilities[]? | "\(.VulnerabilityID)|\(.Severity)|\(.PkgName)|\(.InstalledVersion)|\(.Title // "N/A")"' \
    "${TARGET_SCAN_FILE}" | sort -u > "$OUTPUT_DIR/target_cves.tmp"

# Extract just CVE IDs for comparison
cut -d'|' -f1 "$OUTPUT_DIR/base_cves.tmp" | sort -u > "$OUTPUT_DIR/base_cve_ids.tmp"
cut -d'|' -f1 "$OUTPUT_DIR/target_cves.tmp" | sort -u > "$OUTPUT_DIR/target_cve_ids.tmp"

# Compare CVEs
echo "[3/3] Generating comparison reports..."

# Fixed CVEs (in base but not in target)
comm -23 "$OUTPUT_DIR/base_cve_ids.tmp" "$OUTPUT_DIR/target_cve_ids.tmp" > "$OUTPUT_DIR/fixed_cve_ids.tmp"

# New CVEs (in target but not in base)
comm -13 "$OUTPUT_DIR/base_cve_ids.tmp" "$OUTPUT_DIR/target_cve_ids.tmp" > "$OUTPUT_DIR/new_cve_ids.tmp"

# Common CVEs (in both)
comm -12 "$OUTPUT_DIR/base_cve_ids.tmp" "$OUTPUT_DIR/target_cve_ids.tmp" > "$OUTPUT_DIR/common_cve_ids.tmp"

# Generate detailed reports
generate_detailed_report() {
    local cve_ids_file="$1"
    local cve_details_file="$2"
    local output_file="$3"
    local header="$4"

    echo "$header" > "$output_file"
    echo "========================================" >> "$output_file"
    echo "" >> "$output_file"

    if [ ! -s "$cve_ids_file" ]; then
        echo "No CVEs found." >> "$output_file"
        return
    fi

    while IFS= read -r cve_id; do
        grep "^$cve_id|" "$cve_details_file" | while IFS='|' read -r id severity pkg version title; do
            {
                echo "CVE ID:       $id"
                echo "Severity:     $severity"
                echo "Package:      $pkg"
                echo "Version:      $version"
                echo "Title:        $title"
                echo "----------------------------------------"
            } >> "$output_file"
        done
    done < "$cve_ids_file"

    echo "" >> "$output_file"
    echo "Total: $(wc -l < "$cve_ids_file") unique CVEs" >> "$output_file"
}

# Generate reports
generate_detailed_report "$OUTPUT_DIR/fixed_cve_ids.tmp" "$OUTPUT_DIR/base_cves.tmp" \
    "$OUTPUT_DIR/fixed_cves.txt" "FIXED CVEs (in base image, not in target)"

generate_detailed_report "$OUTPUT_DIR/new_cve_ids.tmp" "$OUTPUT_DIR/target_cves.tmp" \
    "$OUTPUT_DIR/new_cves.txt" "NEW CVEs (in target image, not in base)"

generate_detailed_report "$OUTPUT_DIR/common_cve_ids.tmp" "$OUTPUT_DIR/target_cves.tmp" \
    "$OUTPUT_DIR/common_cves.txt" "COMMON CVEs (in both images)"

# Count severities
count_severity() {
    local cve_ids_file="$1"
    local cve_details_file="$2"
    local severity="$3"

    local count=0
    while IFS= read -r cve_id; do
        if grep -q "^$cve_id|$severity|" "$cve_details_file"; then
            ((count++)) || true
        fi
    done < "$cve_ids_file"
    echo "$count"
}

# Generate summary
{
    echo "CVE COMPARISON SUMMARY"
    echo "=========================================="
    echo ""
    echo "Base Image:   $BASE_IMAGE"
    echo "Target Image: $TARGET_IMAGE"
    echo "Scan Date:    $(date '+%Y-%m-%d %H:%M:%S')"
    echo ""
    echo "=========================================="
    echo "OVERALL STATISTICS"
    echo "=========================================="
    echo ""

    TOTAL_BASE=$(wc -l < "$OUTPUT_DIR/base_cve_ids.tmp")
    TOTAL_TARGET=$(wc -l < "$OUTPUT_DIR/target_cve_ids.tmp")
    TOTAL_FIXED=$(wc -l < "$OUTPUT_DIR/fixed_cve_ids.tmp")
    TOTAL_NEW=$(wc -l < "$OUTPUT_DIR/new_cve_ids.tmp")
    TOTAL_COMMON=$(wc -l < "$OUTPUT_DIR/common_cve_ids.tmp")

    echo "Total CVEs in base image:     $TOTAL_BASE"
    echo "Total CVEs in target image:   $TOTAL_TARGET"
    echo ""
    echo "Fixed CVEs:                   $TOTAL_FIXED"
    echo "New CVEs:                     $TOTAL_NEW"
    echo "Common CVEs:                  $TOTAL_COMMON"
    echo ""

    NET_CHANGE=$((TOTAL_TARGET - TOTAL_BASE))
    if [ $NET_CHANGE -lt 0 ]; then
        echo "Net Change:                   $NET_CHANGE (IMPROVED)"
    elif [ $NET_CHANGE -gt 0 ]; then
        echo "Net Change:                   +$NET_CHANGE (DEGRADED)"
    else
        echo "Net Change:                   0 (NO CHANGE)"
    fi
    echo ""

    echo "=========================================="
    echo "FIXED CVEs BY SEVERITY"
    echo "=========================================="
    echo ""
    if [ -s "$OUTPUT_DIR/fixed_cve_ids.tmp" ]; then
        echo "CRITICAL: $(count_severity "$OUTPUT_DIR/fixed_cve_ids.tmp" "$OUTPUT_DIR/base_cves.tmp" "CRITICAL")"
        echo "HIGH:     $(count_severity "$OUTPUT_DIR/fixed_cve_ids.tmp" "$OUTPUT_DIR/base_cves.tmp" "HIGH")"
        echo "MEDIUM:   $(count_severity "$OUTPUT_DIR/fixed_cve_ids.tmp" "$OUTPUT_DIR/base_cves.tmp" "MEDIUM")"
        echo "LOW:      $(count_severity "$OUTPUT_DIR/fixed_cve_ids.tmp" "$OUTPUT_DIR/base_cves.tmp" "LOW")"
    else
        echo "No CVEs fixed"
    fi
    echo ""

    echo "=========================================="
    echo "NEW CVEs BY SEVERITY"
    echo "=========================================="
    echo ""
    if [ -s "$OUTPUT_DIR/new_cve_ids.tmp" ]; then
        echo "CRITICAL: $(count_severity "$OUTPUT_DIR/new_cve_ids.tmp" "$OUTPUT_DIR/target_cves.tmp" "CRITICAL")"
        echo "HIGH:     $(count_severity "$OUTPUT_DIR/new_cve_ids.tmp" "$OUTPUT_DIR/target_cves.tmp" "HIGH")"
        echo "MEDIUM:   $(count_severity "$OUTPUT_DIR/new_cve_ids.tmp" "$OUTPUT_DIR/target_cves.tmp" "MEDIUM")"
        echo "LOW:      $(count_severity "$OUTPUT_DIR/new_cve_ids.tmp" "$OUTPUT_DIR/target_cves.tmp" "LOW")"
    else
        echo "No new CVEs introduced"
    fi
    echo ""

    echo "=========================================="
    echo "RECOMMENDATION"
    echo "=========================================="
    echo ""

    NEW_CRITICAL=$(count_severity "$OUTPUT_DIR/new_cve_ids.tmp" "$OUTPUT_DIR/target_cves.tmp" "CRITICAL")
    NEW_HIGH=$(count_severity "$OUTPUT_DIR/new_cve_ids.tmp" "$OUTPUT_DIR/target_cves.tmp" "HIGH")

    if [ "$NEW_CRITICAL" -gt 0 ] || [ "$NEW_HIGH" -gt 0 ]; then
        echo "CAUTION: New CRITICAL or HIGH severity CVEs detected"
        echo "Review new_cves.txt before deploying to production"
    elif [ "$NET_CHANGE" -lt 0 ]; then
        echo "RECOMMENDED: Security posture improved"
        echo "Net reduction of $((NET_CHANGE * -1)) CVEs"
    elif [ "$NET_CHANGE" -eq 0 ] && [ "$TOTAL_FIXED" -gt 0 ]; then
        echo "ACCEPTABLE: CVEs fixed but new ones introduced"
        echo "Review the trade-offs in fixed_cves.txt and new_cves.txt"
    else
        echo "REVIEW: Assess impact based on your security requirements"
    fi
    echo ""

    echo "=========================================="
    echo "OUTPUT FILES"
    echo "=========================================="
    echo ""
    echo "Summary:           $OUTPUT_DIR/summary.txt"
    echo "Fixed CVEs:        $OUTPUT_DIR/fixed_cves.txt"
    echo "New CVEs:          $OUTPUT_DIR/new_cves.txt"
    echo "Common CVEs:       $OUTPUT_DIR/common_cves.txt"
    echo "Base scan:         ${BASE_SCAN_FILE}"
    echo "Target scan:       ${TARGET_SCAN_FILE}"
    echo "OCI cache:         ${OCI_CACHE_DIR} (can be deleted after successful run)"
    echo ""
} > "$OUTPUT_DIR/summary.txt"

# Clean up temporary files
rm -f "$OUTPUT_DIR"/*.tmp "$OUTPUT_DIR"/.base_scan_file.tmp "$OUTPUT_DIR"/.target_scan_file.tmp

# Display summary to console
echo ""
echo "CVE comparison complete!"
echo ""
cat "$OUTPUT_DIR/summary.txt"
echo ""
echo "Detailed reports saved to: $OUTPUT_DIR"
