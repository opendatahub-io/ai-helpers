# Generated by Claude Code
"""
Markdown formatting for Slack thread export.

This module handles formatting Slack thread messages as markdown
for upload to JIRA.
"""

from dataclasses import dataclass
from datetime import datetime, timezone

from slack_fetcher import SlackThread, ThreadMessage


@dataclass
class MarkdownExport:
    """
    Represents the formatted markdown document ready for JIRA upload.

    Attributes:
        ticket_key: Target JIRA ticket (e.g., "JN-1234")
        thread_url: Original Slack thread URL
        channel_name: Slack channel name
        export_timestamp: ISO 8601 timestamp of export
        summary: AI-generated summary (if enabled)
        transcript: Formatted message transcript
        is_truncated: Whether thread was truncated
        total_message_count: Total messages in thread
        included_message_count: Messages included in export
    """
    ticket_key: str
    thread_url: str
    channel_name: str
    export_timestamp: str
    summary: str | None
    transcript: str
    is_truncated: bool
    total_message_count: int
    included_message_count: int

    @property
    def full_content(self) -> str:
        """Generate complete markdown content for JIRA comment."""
        header = f"""# Slack Thread Export - {self.ticket_key}

**Exported**: {self.export_timestamp}
**Slack Thread**: {self.thread_url}
**Channel**: {self.channel_name}
"""
        if self.is_truncated:
            header += f"\n⚠️ **Thread truncated**: Showing {self.included_message_count} of {self.total_message_count} messages\n"

        content = header + "\n"

        if self.summary:
            content += f"## Summary\n\n{self.summary}\n\n"

        content += f"## Full Thread Transcript\n\n{self.transcript}"

        return content


def merge_consecutive_messages(messages: list[ThreadMessage]) -> list[ThreadMessage]:
    """
    Merge consecutive messages from the same user.

    Args:
        messages: List of thread messages in chronological order

    Returns:
        List with consecutive same-user messages merged

    Example:
        >>> msgs = [msg1_john, msg2_john, msg3_jane]
        >>> merged = merge_consecutive_messages(msgs)
        >>> len(merged)
        2  # John's messages merged, Jane's separate
    """
    if not messages:
        return []

    merged = [messages[0]]
    for msg in messages[1:]:
        if msg.user_id == merged[-1].user_id:
            # Merge: append text with double newline separator
            merged[-1].text += f"\n\n{msg.text}"
            # Keep timestamp of first message
        else:
            merged.append(msg)

    return merged


def format_thread_to_markdown(
    thread: SlackThread,
    ticket_key: str,
    thread_url: str
) -> MarkdownExport:
    """
    Format Slack thread as markdown for JIRA export.

    Args:
        thread: SlackThread object with messages
        ticket_key: Target JIRA ticket key
        thread_url: Original Slack thread URL

    Returns:
        MarkdownExport object ready for upload
    """
    # Merge consecutive messages from same user
    merged_messages = merge_consecutive_messages(thread.messages)

    # Format each message
    transcript_lines = []
    for msg in merged_messages:
        # Format timestamp
        ts_parts = msg.timestamp.split('.')
        ts = datetime.fromtimestamp(int(ts_parts[0]), tz=timezone.utc)
        formatted_ts = ts.strftime("%Y-%m-%d %H:%M:%S")

        # Format message block
        transcript_lines.append(f"### {msg.user_name} - {formatted_ts}")
        transcript_lines.append(msg.text)
        transcript_lines.append("")  # Blank line between messages

    transcript = "\n".join(transcript_lines)

    return MarkdownExport(
        ticket_key=ticket_key,
        thread_url=thread_url,
        channel_name=thread.channel_name or thread.channel_id,
        export_timestamp=datetime.now(timezone.utc).isoformat(),
        summary=None,  # Summary generation handled separately
        transcript=transcript,
        is_truncated=thread.is_truncated,
        total_message_count=thread.total_message_count,
        included_message_count=len(thread.messages)
    )
